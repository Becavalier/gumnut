<!DOCTYPE html>
<html>
<head>
<script type="module">

import * as utils from './utils.js';

let globalCallback;

const importObject = (function() {
  const env = {
    memory: new WebAssembly.Memory({initial: 256, maximum: 256}),
    table: new WebAssembly.Table({initial: 2, maximum: 2, element: 'anyfunc'}),
    __table_base: 0,

    abort(arg) {
      throw new Error(`abort: ${arg}`);
    },

    // callbacks here
    _token_callback(p, len, line_no, type, mark) {
      globalCallback(p, len, line_no, type, mark);
    },
  };

  return {env};
}());

const ready = utils.createWebAssembly('runner.wasm', importObject)
    .catch((err) => console.warn('err loading wasm', err));
const exports = ready.then((wa) => wa.instance.exports);

const TOKENS = {
  EOF: 0,
  SEMICOLON: 1,

  COMMA: 2,
  SPREAD: 3,
  DOT: 4,
  OP: 5,
  ARROW: 6,
  COLON: 7,
  BRACE: 8,
  ARRAY: 9,
  PAREN: 10,
  T_BRACE: 11,
  TERNARY: 12,
  CLOSE: 13,

  COMMENT: 14,
  STRING: 15,
  REGEXP: 16,
  NUMBER: 17,
  SYMBOL: 18,
  KEYWORD: 19,
  LABEL: 20,

  LIT: 29,
  SLASH: 30,
  INTERNAL: 31,
};

const REVERSE = (function() {
  const m = new Map();
  Object.keys(TOKENS).forEach((key) => {
    m.set(TOKENS[key], key);
  });
  return m;
}());

window.addEventListener('load', (ev) => {
  const append = (text, type='') => {
    const node = document.createElement('span');
    node.textContent = String(text).replace(/\n*$/, '');
    if (type[0] !== '_') {
      node.title = type.toLowerCase();
    }
    node.className = type.toLowerCase();
    node.title = type;
    output.appendChild(document.createTextNode(' '));
    output.appendChild(node);
    return node;
  };
  const appendLine = () => {
    if (output.childNodes.length && output.lastChild.textContent != '\n') {
      output.appendChild(document.createTextNode('\n'));
    }
  };

  const render = (tokens, view) => {
    let lineNo = undefined;
    output.textContent = '';
    tokens.forEach((token) => {
      if (token.lineNo !== lineNo) {
        lineNo = token.lineNo;
        appendLine();
        append(token.lineNo, '_lineno');
      }

      const s = view.read(token.at, token.len);
      const node = append(s, REVERSE.get(token.type));

      if (token.invalid) {
        node.classList.add('_invalid');
      }

      switch (token.type) {
      case TOKENS.SEMICOLON:
        if (!s) {
          node.textContent = ';';
          node.classList.add('_asi');
        }
        break;
      }

      node.tabIndex = 0;
    });
  };

  ready.then((wa) => {
    const exports = wa.instance.exports;
    const memory = wa.importObject.env.memory;

    const update = () => {
      const raw = input.value;
      const view = new utils.CodeView(memory, raw);
      exports._prsr_setup(view.at);

      const futureLitResolve = new Map();
      const tokens = [];
      const start = performance.now();

      let err = 0;
      try {
        globalCallback = (at, len, lineNo, type, mark) => {
          const token = {at, len, lineNo, type, invalid: false};

          // if we have find LIT, it's probably an ambiguous "async () =>", so save it for later
          if (token.type == TOKENS.LIT) {
            futureLitResolve.set(token.at, token);
          }

          tokens.push(token);
        };
        for (;;) {
          err = exports._prsr_run(0);
          // TODO: call many times if valid
          break;
        }
      } catch (thrown) {
        console.error(thrown);
        err = thrown;
      }

      const took = performance.now() - start;
      stats.textContent = `${took.toLocaleString({minimumSignificantDigits: 8})}ms`;
      if (err) {
        stats.textContent += ` err=`;
        const em = document.createElement('em');
        em.textContent = err;
        stats.appendChild(em);
      }
      render(tokens, view);
    };

    let rAF;
    const dedup = () => {
      window.cancelAnimationFrame(rAF);
      rAF = window.requestAnimationFrame(() => {
        let v = null;
        if (input.value.length <= 4096) {
          // just give up if it's too large
          v = window.encodeURIComponent(input.value);
        }
        if (v) {
          window.history.replaceState(null, null, '#' + v);
        } else {
          window.history.replaceState(null, null, window.location.pathname);
        }
        update();
      });
    };
    input.oninput = dedup;
    dedup();
  });
});

document.addEventListener('dragover', (ev) => {
  ev.preventDefault();
});
document.addEventListener('drop', (ev) => {
  ev.preventDefault();
  const file = ev.dataTransfer.files[0];

  if (!file) { return; }

  const reader = new FileReader();
  reader.onload = (ev) => {
    input.value = ev.target.result;
    input.dispatchEvent(new CustomEvent('input'));
  };
  reader.readAsText(file);
});

</script>
<style>
  textarea {
    font-family: monospace;
    resize: none;
  }
  pre {
    cursor: pointer;
  }
  pre span._lineno {
    background: purple;
    font-style: italic;
    color: white;
  }
  pre span._asi {
    background: green;
    color: white;
  }
  pre span.comment {
    color: green;
  }
  pre span.keyword {
    color: purple;
    font-weight: bold;
  }
  pre span.number,
  pre span.string,
  pre span.regexp {
    color: red;
  }
  pre span.op {
    color: purple;
  }
  pre span.label {
    color: brown;
  }
  pre span.symbol {
    color: blue;
  }
  pre span.lit {
    background: red;
    color: white;
  }
  pre span._invalid {
    text-decoration: underline;
  }
</style>
</head>
<body>

<div>
  <a href="https://github.com/samthor/prsr">GitHub</a>
</div>

<textarea id="input" rows="20" cols="100"></textarea>
<script>
window.addEventListener('hashchange', (ev) => {
  input.value = window.decodeURIComponent(window.location.hash.substr(1));
});
window.dispatchEvent(new CustomEvent('hashchange'));
</script>

<div id="stats">
</div>

<pre id="output"></pre>

</body>
</html>
